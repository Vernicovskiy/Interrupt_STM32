![Static Badge](https://img.shields.io/badge/Unic_Lab-green)
![Static Badge](https://img.shields.io/badge/STM32-red)
![GitHub last commit (by committer)](https://img.shields.io/github/last-commit/Vernicovskiy/STM32_TIM)
![GitHub Repo stars](https://img.shields.io/github/stars/Vernicovskiy/STM32_TIM)
![GitHub watchers](https://img.shields.io/github/watchers/Vernicovskiy/STM32_TIM)
![GitHub top language](https://img.shields.io/github/languages/top/Vernicovskiy/STM32_TIM)







# Таймер STM32 в режиме частотомера
 * NUCLEO-F401RE
 * STM32F401RET6U
 * ARM Cortex M4
 * HAL
 * STM32 CubeIDE v1.13.2

>Программа реализует подсчет внешней частоты с помощью таймера TIM2. Таймер тактируется от измеряемой частоты, в нашем случае с MCO1  через ETR-пин.

Таймер TIM1 будет отмерять интервал времени равный одной секунде. Таймер TIM2 будет тактироваться от измеряемой частоты через ETR-пин, и тем самым его счётчик будет выступать в роли счётчика импульсов. TIM2 32-х битный, следовательно TIM2 сможет насчитать 4294967295 импульсов, что убирает барьер каскадного подключения таймеров при использовании 16-ти битных таймеров.

1. Настраиваем систему тактирования на максимум -> 84MHz
   
---
<details>
  <summary>Особенность шины APB1</summary>
  Если для тактирования шины APB1 используется делитель больше 1, то тактирование таймеров происходит с частотой в 2 раза больше частоты тактового сигнала в шине. То есть, если для шины установить делитель /2, то у таймера появится множитель X2

  ![Alt text](image-7.png)
</details>   

---

2. Источник тактирование для TIM2
   
![Alt text](image.png)

3. Активируем пин RCC_MCO1 (Master Clock Output 1), он будет выдавать частоту для проверки нашего частотомера

![Alt text](image-1.png)

4. Указываем максимальную скорость (Maximum output speed) для пина PA8

![Alt text](image-2.png)
---
<details>
  <summary>Скоростные характеристики портов</summary>

![Alt text](image-4.png)
![Alt text](image-5.png)
![Alt text](image-3.png)
![Alt text](image-6.png)

</details>   

---
 5. Источником для выхода MCO указываем PLL
   
![Alt text](image-8.png)

Перед бесконечным циклом запускаем TIM1 в режиме прерывания, и активируем TIM2

```C
//...
HAL_TIM_Base_Start_IT(&htim1);
HAL_TIM_Base_Start(&htim2);
//...
```
Добавляем функцию Callback
```C
//...
 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){

	if (htim == &htim1){

			  count_main = __HAL_TIM_GET_COUNTER(&htim2);
			  HAL_TIM_Base_Stop_IT(&htim1);
			  __HAL_TIM_SET_COUNTER(&htim2, 0x0000);
			  HAL_TIM_Base_Start_IT(&htim1);
	}
}
//...
```
Результат точный

![Alt text](image-9.png)

Для 42MHz

![Alt text](image-10.png)

Cейчас микроконтроллер измеряет частоту, которую он сам и выдаёт, то есть таймеры занимающиеся подсчётом, синхронизированы с этой частотой 
> Когда и ядро, и таймеры, и другая периферия тактируется от одного источника, то в микроконтроллере всё работает синхронно. В нашем случае микроконтроллер тактируется от HSI

Но если подать сигнал с другого источника тактирования, то значение будет искажаться. И с увеличением частоты погрешность будет увеличиваться 

![Alt text](image-11.png)

Входящая частота приходит на ETR-пин, попадает в асинхронный предделитель, делится там, попадает в фильтр, где выполняется сэмплирование этого сигнала с помощью системной частоты — fDTS.

![Alt text](image-12.png)

Входящий сигнал сэмплируется системной частотой таймера (выборки). Если в течении заданного количества выборок сигнал был стабилен, то всё окей, если же он переключился раньше чем закончились выборки, то это расценивается как дребезг и отвергается.

Частота и количество сэмплов (выборок) задаётся цифрами от 0 до 15, которые соответствуют следующим фильтрам:
![Alt text](image-21.png)
![Alt text](image-18.png)
![Alt text](image-19.png)
![Alt text](image-20.png)


Ниже представлен пример

![Alt text](image-17.png)
TCK_INT
Опорной частотой для сэмплирования служит системная частота таймера.

**TDTS** -
Вспомогательный тактовый сигнал. Частота TDTS получается после того, как частота TCK_INT делится делителем Internal Clock Division (CKD) на два. Если CKD не используется, то TDTS будет равна TCK_INT.

>CKD применяется в том случае, если нужно увеличить время исследования сигнала — частота сэмплов уменьшится, следовательно проверка будет происходить дольше.

**TSAMPLING** -
Применяя фильтр fSAMPLING=fDTS/2, N=6 к частоте TDTS мы делим её на два, и получаем частоту сэмплирования — TSAMPLING в четыре раза меньше системной частоты таймера. Количество сэмплов будет 6.

В итоге к входящему сигналу будет применено шесть выборок. Если на протяжении этого времени сигнал не менял полярность, то всё окей. Любой сигнал с меньшей длительностью будет отклонён.

Так как все шесть выборок были успешные, отфильтрованный сигнал (Filtred signal) переключился в HIGH. Как видно, переключение отфильтрованных сигналов будет происходить с небольшим сдвигом во времени, равным времени выборок.

Если планируется использовать фильтр, то его нужно подбирать так, чтоб он был меньше длины импульса входящего сигнала.

![Alt text](image-13.png)
> Таймер STM32 синхронизирует внешний тактовый сигнал со своим собственным(тактовый сигнал шины APB). Синхронизированный тактовый сигнал подается на предделитель таймера, который, в свою очередь, подает сигнал на счетчик таймера.

![Alt text](image-14.png)
![Alt text](image-16.png)
![Alt text](image-15.png)

Из теоремы Котельникова следует что для успешной дискретизации сигнала, системная частота должна более чем в два раза превышать измеряемую, а в мануале на микроконтроллер говориться что системная частота должна быть выше в три раза.
Максимальная измеряемая частота зависит от того, на какой частоте работает сам микроконтроллер, если на 84МГц, то можно измерить частоту около 224 МГц.



При старте, таймер TIM1 будет аппаратно подавать этот сигнал на TIM2 и тем самым запускать его.






